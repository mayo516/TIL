<h1>섹션27 비동기식 JavaScript</h1>

<h2> The Call Stack </h2>

콜 스택 = JS가 함수호출을 관리하는 방식. 
책 속의 손가락 같은 것. 
스택 = 자료구조 ( 후입선출 )  , 팬케이크가 쌓여있는 것 같다. 
가장 최근에 추가한 것을삭제함 

- 콜 스택은 JS가 사용하는 매커니즘으로 여러 함수를 호출하는 스크립트에서 해당 위치를 호출한다. 
스크립트가 함수를 호출하면 해석기는 콜 스택에 추가합니다. 

- 첫 번째 함수가 호출한 다른 함수도 콜 스택에 추가되어 호출되면 실행됩니다. 현재 함수가 완료되면 
해석기는 콜 스택에서 함수를 제거하고 마지막 코드 목록의 멈춘 곳에서 계속 실행합니다. 

![image](https://user-images.githubusercontent.com/70703716/180751475-8874fdce-a28f-4a96-ae32-9ab559b6bf5f.png)

스택이 쌓였다가 사라지는 과정을 이해해야한다. 

---> loupe라는 도구, 도구-Soures 에서 그 과정 확인 가능. 

<h2>WebAPI와 단일스레드</h2>

JS는 단일 스레드이다. 
---> 멀티 테스킹을 할 수 없다. 따라서 최대 한 줄의 코드만 실행한다. 

```
setTimeOut(()=> 
  console.log('서버에 보내는 중...')
{},3000);

console.log('마지막파일입니다')

---> 이 경우에 서버에 보내는 중 이전에 마지막 파일입니다가 나온다. 왜?그럴까?

```
이유 : 자바스크립트가 아니라 브라우저가 작업하고 있다. 브라우저는 c++와 같은 다른 언어로 만들어 져서 
자바스크립트가 할 수 없는 것들을 한다. 브라우저는 WebAPI를  가지고 있고 이는 배후에서 일어난다. 
브라우저로 작업을 넘긴다. 
브라우저는 3초라는 공백을 계산해서 *콜스택*에 추가한다. 

<h2> 콜백이라는 지옥 </h2>

함수들을 중첩시키면 콜백 지옥이 만들어진다. 

![image](https://user-images.githubusercontent.com/70703716/180755088-3d835402-c7f6-4412-b5cf-458bf89c8c36.png)

![image](https://user-images.githubusercontent.com/70703716/180755559-a516b35e-b414-4476-ab78-60ca7e9e5555.png)1, 

하나 이상의 콜백이 있는 경우는 흔하다. 

![image](https://user-images.githubusercontent.com/70703716/180756072-efbfd435-2a47-4f25-bfb3-e6d8cf88ac6f.png)

가상의 함수이다. 콜백을 전달한다. 
이 경우 자바스크립트의 문제인 콜백 지옥이 나타날 수 있다. 정해지지 않은 시점의 일을 하려고 할 때 발생.

---> Promise와 비동기 함수로 해결할 수 있다. 
